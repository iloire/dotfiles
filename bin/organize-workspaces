#!/bin/bash
# Category: files
# Description: Organize windows across workspaces using JSON config
#
# Organizes windows across workspaces based on JSON config
# Requires: wmctrl, jq
# Install: sudo apt install wmctrl jq
#

set -euo pipefail

CONFIG_DIR="${HOME}/myconfig/organize-workspaces"
CONFIG_NAME="${1:-default}"

# If argument is a path to a file, use it directly; otherwise treat as config name
if [[ -f "$CONFIG_NAME" ]]; then
    CONFIG_FILE="$CONFIG_NAME"
elif [[ -f "${CONFIG_DIR}/${CONFIG_NAME}.json" ]]; then
    CONFIG_FILE="${CONFIG_DIR}/${CONFIG_NAME}.json"
else
    echo "Error: Config not found: $CONFIG_NAME"
    echo "Available configs:"
    ls -1 "$CONFIG_DIR"/*.json 2>/dev/null | xargs -I{} basename {} .json | sed 's/^/  /'
    exit 1
fi

for cmd in wmctrl jq; do
    if ! command -v "$cmd" &>/dev/null; then
        echo "Error: $cmd is required. Install with: sudo apt install $cmd"
        exit 1
    fi
done

if [[ ! -f "$CONFIG_FILE" ]]; then
    echo "Error: Config file not found: $CONFIG_FILE"
    exit 1
fi

echo "Loading config from: $CONFIG_FILE"

# Parse monitors from config
declare -A MONITOR_X MONITOR_Y MONITOR_W MONITOR_H
while IFS= read -r line; do
    name=$(echo "$line" | jq -r '.name')
    MONITOR_X[$name]=$(echo "$line" | jq -r '.x')
    MONITOR_Y[$name]=$(echo "$line" | jq -r '.y')
    MONITOR_W[$name]=$(echo "$line" | jq -r '.width')
    MONITOR_H[$name]=$(echo "$line" | jq -r '.height')
done < <(jq -c '.monitors[]' "$CONFIG_FILE")

# Parse positions from config
declare -A POS_X POS_Y POS_W POS_H
while IFS= read -r line; do
    name=$(echo "$line" | jq -r '.key')
    POS_X[$name]=$(echo "$line" | jq -r '.value.x')
    POS_Y[$name]=$(echo "$line" | jq -r '.value.y')
    POS_W[$name]=$(echo "$line" | jq -r '.value.width')
    POS_H[$name]=$(echo "$line" | jq -r '.value.height')
done < <(jq -c '.positions | to_entries[] | {key: .key, value: .value}' "$CONFIG_FILE")

# Parse chrome profiles
declare -A CHROME_PROFILES
while IFS= read -r line; do
    key=$(echo "$line" | jq -r '.key')
    value=$(echo "$line" | jq -r '.value')
    CHROME_PROFILES[$key]="$value"
done < <(jq -c '.chrome_profiles | to_entries[]' "$CONFIG_FILE")

# Get monitor name from alias (left, center, right)
get_monitor_name() {
    local alias="$1"
    jq -r ".monitors.$alias.name" "$CONFIG_FILE"
}

# Get top bar offset from config (default 0)
TOP_BAR_OFFSET=$(jq -r '.top_bar_offset // 0' "$CONFIG_FILE")

# Calculate absolute position
calc_position() {
    local monitor_alias="$1"
    local position="$2"

    local mon_name
    mon_name=$(get_monitor_name "$monitor_alias")

    local mon_x=${MONITOR_X[$mon_name]}
    local mon_y=${MONITOR_Y[$mon_name]}
    local mon_w=${MONITOR_W[$mon_name]}
    local mon_h=${MONITOR_H[$mon_name]}

    local pos_x=${POS_X[$position]}
    local pos_y=${POS_Y[$position]}
    local pos_w=${POS_W[$position]}
    local pos_h=${POS_H[$position]}

    # Effective monitor height after top bar offset
    local effective_h=$((mon_h - TOP_BAR_OFFSET))

    # Calculate absolute coordinates (y offset applied, height reduced)
    local abs_x=$(echo "$mon_x + ($mon_w * $pos_x)" | bc | cut -d. -f1)
    local abs_y=$(echo "$mon_y + $TOP_BAR_OFFSET + ($effective_h * $pos_y)" | bc | cut -d. -f1)
    local abs_w=$(echo "$mon_w * $pos_w" | bc | cut -d. -f1)
    local abs_h=$(echo "$effective_h * $pos_h" | bc | cut -d. -f1)

    echo "$abs_x,$abs_y,$abs_w,$abs_h"
}

# Track used windows to avoid reusing (using temp file for subshell persistence)
USED_WINDOWS_FILE=$(mktemp)
trap "rm -f $USED_WINDOWS_FILE" EXIT

# Persistent state file for Chrome profile -> window mapping (per config)
CONFIG_BASENAME=$(basename "$CONFIG_FILE" .json)
CHROME_STATE_FILE="/tmp/organize-workspaces-chrome-state-${CONFIG_BASENAME}"

is_window_used() {
    grep -q "^$1$" "$USED_WINDOWS_FILE" 2>/dev/null
}

mark_window_used() {
    echo "$1" >> "$USED_WINDOWS_FILE"
}

# Directory for generated workspace files
WORKSPACE_DIR="/tmp/organize-workspaces"
mkdir -p "$WORKSPACE_DIR"

# Get VS Code window for a specific folder, folders array, or workspace file
get_vscode_window() {
    local folder="${1:-}"
    local workspace="${2:-}"
    local folders_json="${3:-}"
    local search_name=""
    local win

    # Priority 1: folders array - generate a workspace file
    if [[ -n "$folders_json" && "$folders_json" != "null" && "$folders_json" != "[]" ]]; then
        # Use first folder's basename as the workspace name for window matching
        search_name=$(echo "$folders_json" | jq -r '.[0]' | xargs basename)
        local workspace_file="$WORKSPACE_DIR/${search_name}.code-workspace"

        # Generate workspace file from folders array
        echo "$folders_json" | jq '{folders: [.[] | {path: .}]}' > "$workspace_file"

        # Try to find existing window
        win=$(wmctrl -l | grep -i "Visual Studio Code" | grep -i "$search_name" | awk '{print $1}' | head -1)
        if [[ -n "$win" ]] && ! is_window_used "$win"; then
            mark_window_used "$win"
            echo "$win"
            return 0
        fi

        # Not found, open the workspace
        echo "Opening VS Code with folders: $search_name..." >&2
        code --new-window "$workspace_file" &>/dev/null &
        sleep 3
        win=$(wmctrl -l | grep -i "Visual Studio Code" | grep -i "$search_name" | awk '{print $1}' | head -1)
        if [[ -n "$win" ]]; then
            mark_window_used "$win"
            echo "$win"
            return 0
        fi
    # Priority 2: workspace file
    elif [[ -n "$workspace" && "$workspace" != "null" ]]; then
        search_name=$(basename "$workspace" .code-workspace)

        # Try to find existing window with this workspace open (workspace name appears in title)
        win=$(wmctrl -l | grep -i "Visual Studio Code" | grep -i "$search_name" | awk '{print $1}' | head -1)
        if [[ -n "$win" ]] && ! is_window_used "$win"; then
            mark_window_used "$win"
            echo "$win"
            return 0
        fi

        # Not found, open the workspace in a new window
        echo "Opening VS Code with workspace: $search_name..." >&2
        code --new-window "$workspace" &>/dev/null &
        sleep 3
        win=$(wmctrl -l | grep -i "Visual Studio Code" | grep -i "$search_name" | awk '{print $1}' | head -1)
        if [[ -n "$win" ]]; then
            mark_window_used "$win"
            echo "$win"
            return 0
        fi
    # Priority 3: single folder
    elif [[ -n "$folder" && "$folder" != "null" ]]; then
        search_name=$(basename "$folder")

        # First, try to find existing window with this folder open
        win=$(wmctrl -l | grep -i "Visual Studio Code" | grep -i "$search_name" | awk '{print $1}' | head -1)
        if [[ -n "$win" ]] && ! is_window_used "$win"; then
            mark_window_used "$win"
            echo "$win"
            return 0
        fi

        # Not found, open the folder in a new window
        echo "Opening VS Code with folder: $search_name..." >&2
        code --new-window "$folder" &>/dev/null &
        sleep 3
        win=$(wmctrl -l | grep -i "Visual Studio Code" | grep -i "$search_name" | awk '{print $1}' | head -1)
        if [[ -n "$win" ]]; then
            mark_window_used "$win"
            echo "$win"
            return 0
        fi
    fi

    # No folder specified or couldn't find/create, use any available window
    while IFS= read -r win; do
        if ! is_window_used "$win"; then
            mark_window_used "$win"
            echo "$win"
            return 0
        fi
    done < <(wmctrl -l | grep -i "Visual Studio Code" | awk '{print $1}')

    # No available window, create one
    echo "Creating new VS Code window..." >&2
    code --new-window &>/dev/null &
    sleep 3
    win=$(wmctrl -l | grep -i "Visual Studio Code" | tail -1 | awk '{print $1}')
    if [[ -n "$win" ]] && ! is_window_used "$win"; then
        mark_window_used "$win"
        echo "$win"
    fi
}

# Get saved Chrome window for profile from state file
get_saved_chrome_window() {
    local profile_alias="$1"
    if [[ -f "$CHROME_STATE_FILE" ]]; then
        grep "^$profile_alias:" "$CHROME_STATE_FILE" 2>/dev/null | cut -d: -f2
    fi
}

# Save Chrome window for profile to state file
save_chrome_window() {
    local profile_alias="$1"
    local win_id="$2"
    # Remove old entry for this profile, then add new one
    if [[ -f "$CHROME_STATE_FILE" ]]; then
        grep -v "^$profile_alias:" "$CHROME_STATE_FILE" > "${CHROME_STATE_FILE}.tmp" 2>/dev/null || true
        mv "${CHROME_STATE_FILE}.tmp" "$CHROME_STATE_FILE"
    fi
    echo "$profile_alias:$win_id" >> "$CHROME_STATE_FILE"
}

# Check if a window ID still exists
window_exists() {
    local win_id="$1"
    wmctrl -l | grep -q "^$win_id "
}

# Get Chrome window for profile, reusing saved window if it still exists
get_chrome_window() {
    local profile_alias="$1"
    local profile_dir="${CHROME_PROFILES[$profile_alias]}"

    # First, check if we have a saved window for this profile that still exists
    local saved_win
    saved_win=$(get_saved_chrome_window "$profile_alias")
    if [[ -n "$saved_win" ]] && window_exists "$saved_win" && ! is_window_used "$saved_win"; then
        echo "Reusing existing Chrome window for profile: $profile_alias" >&2
        mark_window_used "$saved_win"
        echo "$saved_win"
        return 0
    fi

    # No saved window available, create a new one with the correct profile
    local before_windows
    before_windows=$(wmctrl -l | grep -i "Chrome" | awk '{print $1}' | sort)

    echo "Launching Chrome window (profile: $profile_alias)..." >&2
    nohup google-chrome --new-window --profile-directory="$profile_dir" "about:blank" > /dev/null 2>&1 &
    sleep 3

    # Find the newly created window by comparing before/after
    local after_windows
    after_windows=$(wmctrl -l | grep -i "Chrome" | awk '{print $1}' | sort)

    local new_win
    new_win=$(comm -13 <(echo "$before_windows") <(echo "$after_windows") | head -1)

    if [[ -n "$new_win" ]] && ! is_window_used "$new_win"; then
        mark_window_used "$new_win"
        save_chrome_window "$profile_alias" "$new_win"
        echo "$new_win"
        return 0
    fi
}

# Get next available terminal window, or create one
get_terminal_window() {
    local win
    # Match terminals by common patterns: username@hostname, or terminal app names
    while IFS= read -r win; do
        if ! is_window_used "$win"; then
            mark_window_used "$win"
            echo "$win"
            return 0
        fi
    done < <(wmctrl -l | grep -iE "terminal|terminator|konsole|kitty|alacritty|@.*:" | grep -vi "Visual Studio Code\|Chrome\|Obsidian" | awk '{print $1}')

    # No available window, create one
    echo "Creating new terminal window..." >&2
    gnome-terminal &>/dev/null &
    sleep 2
    win=$(wmctrl -l | grep -iE "terminal|terminator|konsole|kitty|alacritty|@.*:" | grep -vi "Visual Studio Code\|Chrome\|Obsidian" | tail -1 | awk '{print $1}')
    if [[ -n "$win" ]] && ! is_window_used "$win"; then
        mark_window_used "$win"
        echo "$win"
    fi
}

# Get next available Obsidian window
get_obsidian_window() {
    local win
    while IFS= read -r win; do
        if ! is_window_used "$win"; then
            mark_window_used "$win"
            echo "$win"
            return 0
        fi
    done < <(wmctrl -l | grep -i "Obsidian" | awk '{print $1}')

    echo "Warning: No Obsidian window found. Please open Obsidian first." >&2
}

# Get next available TODO app window
get_todo_window() {
    local win
    # Match common TODO apps: Todoist, Microsoft To Do, or window titled "Today"
    while IFS= read -r win; do
        if ! is_window_used "$win"; then
            mark_window_used "$win"
            echo "$win"
            return 0
        fi
    done < <(wmctrl -l | grep -E "todoist|to.do|tasks|todo|Today" | grep -vi "Chrome\|Obsidian" | awk '{print $1}')

    echo "Warning: No TODO app window found. Please open your TODO app first." >&2
}

# Process each workspace
num_workspaces=$(jq '.workspaces | length' "$CONFIG_FILE")

for ((ws_idx = 0; ws_idx < num_workspaces; ws_idx++)); do
    ws_name=$(jq -r ".workspaces[$ws_idx].name" "$CONFIG_FILE")
    ws_num=$(jq -r ".workspaces[$ws_idx].workspace" "$CONFIG_FILE")

    echo ""
    echo "=== $ws_name (workspace $((ws_num + 1))) ==="

    num_windows=$(jq ".workspaces[$ws_idx].windows | length" "$CONFIG_FILE")

    for ((win_idx = 0; win_idx < num_windows; win_idx++)); do
        app=$(jq -r ".workspaces[$ws_idx].windows[$win_idx].app" "$CONFIG_FILE")
        monitor=$(jq -r ".workspaces[$ws_idx].windows[$win_idx].monitor" "$CONFIG_FILE")
        position=$(jq -r ".workspaces[$ws_idx].windows[$win_idx].position" "$CONFIG_FILE")

        # Get window ID
        win_id=""
        case "$app" in
            vscode)
                folder=$(jq -r ".workspaces[$ws_idx].windows[$win_idx].folder // empty" "$CONFIG_FILE")
                workspace=$(jq -r ".workspaces[$ws_idx].windows[$win_idx].workspace // empty" "$CONFIG_FILE")
                folders_json=$(jq -c ".workspaces[$ws_idx].windows[$win_idx].folders // empty" "$CONFIG_FILE")
                win_id=$(get_vscode_window "$folder" "$workspace" "$folders_json")
                ;;
            chrome)
                profile=$(jq -r ".workspaces[$ws_idx].windows[$win_idx].profile" "$CONFIG_FILE")
                win_id=$(get_chrome_window "$profile")
                ;;
            terminal)
                win_id=$(get_terminal_window)
                ;;
            obsidian)
                win_id=$(get_obsidian_window)
                ;;
            todo)
                win_id=$(get_todo_window)
                ;;
        esac

        if [[ -z "$win_id" ]]; then
            echo "Warning: Could not get window for $app"
            continue
        fi

        # Calculate position
        coords=$(calc_position "$monitor" "$position")
        IFS=',' read -r x y w h <<< "$coords"

        # Move to workspace and position
        wmctrl -i -r "$win_id" -t "$ws_num"
        wmctrl -i -r "$win_id" -e "0,$x,$y,$w,$h"

        echo "Placed $app on $monitor ($position) -> ${w}x${h}+${x}+${y}"
    done
done

echo ""
echo "Done! Workspaces configured."
